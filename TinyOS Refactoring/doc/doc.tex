\documentclass[a4paper,10pt]{report}
\usepackage[utf8x]{inputenc}

% Code-Listings
\usepackage{listings} 
\lstset{numbers=left, numberstyle=\tiny, numbersep=5pt} 
\lstset{language=Java}

% Glossary
\usepackage{nomencl}
\makenomenclature



% Title Page
\title{Refactoring Extenstion for the Yeti NesC Eclipse Plugin}
\author{Noah Heusser, Max Urech}


\begin{document}
\maketitle

\begin{abstract}
\end{abstract}

\part{What is refactoring}
\chapter{Definition of refactoring}
Wikipedia gives us the following definition for code refactoring:
``Code refactoring is the process of changing a computer program's source code without modifying its external functional behavior in order to improve some of the nonfunctional attributes of the software. 
Advantages include improved code readability  and reduced complexity to improve the maintainability of the source code, as well as a more expressive internal architecture or object model to improve extensibility.''
Since this document is about a refactoring facility for NesC, we are of course actually always referring to code refactoring, when we talk about refactoring.

\chapter{Why do we need refactoring}
Reusability and maintainability are two terms, which are known to everybody, who ever heard something about software engineering. 
A refactoring facility is a means for supporting those properties. I.e. if you want to reuse an existing function in a program in a second place,
you might suddenly realise, that the name of the function actually not really matches its purpose and you consequently want to rename it to a more appropriate name.
If you have a function rename refactoring at hand at this point, you simply have to select the refactoring, type in the name, press enter and you are done. 
Without such a tool you had to replace the function name by hand at every position in the program, where it appears, possibly in different files.
This example is also good for the cast, that refactoring supports maintainability, because a readable program is also a maintainable program. 
And if the names of the different entities in a program match their purpose, the program is for sure more readable, then if they don't.

\part{Eclipse Plugins}
\chapter{General Infos about writeing Plugins}
Eclipse is famous for it's plugin architecture. Everything in Eclipse is a Plugin. An Eclipse Plugin is a JAR-File or a Folder in the plugins-Directory of the eclipse program folder.
To be a plugin it takes at least three Files.
\begin{itemize}
  \item META-INF/MANIFEST.MF
  \item plugin.xml
  \item plugin.class
\end{itemize}

\section{META-INF/MANIFEST.MF}
The Manifest file is the first File that is read by Eclipse while loding the Plugin. It conatins all the Informations about what requirements 
are needed to load the Plugin and how it can be loaded. I will now explain the most important entrys in the Manifest file.

\begin{lstlisting}[caption=MANIFEST]{META-INF/MANIFEST.MF}
Manifest-Version: 1.0
Bundle-ManifestVersion: 2
Bundle-Name: TinyOS_Refactoring
Bundle-SymbolicName: tinyos.yeti.refactoring;singleton:=true
Bundle-Version: 1.0.0
Bundle-Activator: tinyos.yeti.refactoring.RefactoringPlugin
Require-Bundle: org.eclipse.ui,
 org.eclipse.core.runtime,
 tinyos.yeti.core;bundle-version="2.2.17",
 tinyos.yeti.parser.nesc12;bundle-version="1.2.17",
 org.eclipse.ui.workbench.texteditor;bundle-version="3.5.1",
 org.eclipse.ltk.core.refactoring;bundle-version="3.5.0",
 org.eclipse.ltk.ui.refactoring;bundle-version="3.4.101",
 org.eclipse.core.resources;bundle-version="3.5.2",
 org.eclipse.jface.text;bundle-version="3.5.2",
 org.eclipse.ui.ide;bundle-version="3.5.2",
 org.eclipse.ui.editors;bundle-version="3.5.0",
 tinyos.yeti.preprocessor.nesc12;bundle-version="1.2.17",
 org.eclipse.core.expressions;bundle-version="3.4.101"
Bundle-ActivationPolicy: lazy
Bundle-RequiredExecutionEnvironment: JavaSE-1.6
\end{lstlisting}


\begin{description}
 \item[Manifest-Version] This line shows that a manifest's entries take the form of "header: value" pairs. The name of a header is separated from its value by a colon. (from http://java.sun.com/developer/Books/javaprogramming/JAR/basics/manifest.html access 2.9.2010)
 \item[Bundle-ManifestVersion] Manifest header identifying the bundle manifest version. A bundle manifest may express the version of the syntax in which it is written by specifying a bundle manifest version. Bundles exploiting OSGi Release 4, or later, syntax must specify a bundle manifest version. 
The bundle manifest version defined by OSGi Release 4 or, more specifically, by version 1.3 of the OSGi Core Specification is "2". (from Eclipse Help Version: 3.5.2)
 \item[Bundle-Name] A human readable meaningful Name for the Plugin you write.
 \item[Bundle-SymbolicName] A unique String identifyer for you Pulugin. Mostly the Path of your package structure is used. The \verb!singelton:=true! makes the OSGi Framework only load your Plugin once. It has to be set in every Eclipse Plugin. It is only necessary cause Eclipse uses OSGi which is not only used for Eclipse.
 \item[Bundle-Version] Defines the Version of the Plugin. When the Plugin is used by an other Plugin , it can specify the Verserion in the Required-Bundle Parmeter. A Verstion is composed of 3 positive natural numbers and a String seperated by ``.'' sign. Two Versions are equal if the Numbers are Equal. The String in the end might be used to specify different Versions with the absolute same Interface (for example different Compailers). The Nummbers from left to right are called: Major.Minor.Mirco.
 \item[Bundle-Activator] This is the Path of the Class which is used to start the whole Plugin. The class must extend \verb!org.eclipse.core.runtime.Plugin!. 
 \item[Require-Bundle] When you write you plugin you will use the Functionality of other Plugins. To do that you have to specify here which plugins you use. Eclipse will refuse to load your plugin if the Plugins you require are not avialable. In addition you can specify the version of the plugin you need to be available. If you don't specify anything else Eclipse will assume to have an compatible Version as long as there is one having the same Major-Number. In case of you have to be more picky, you can also add a \verb!match! parameter with \verb!perfect! for Major, Minor and Micro Number have to match, or \verb!equivalent! for Major and Minor Number have to match.
 \item[Bundle-ActivationPolicy] The only parameter you can add here is \verb!lazy! which tells OSGi to wait with loading the Plugin until it is used.
 \item[Bundle-RequiredExecutionEnvironment] Defines a lower bound for the Version of the JVM that is allowed to be used.
 \end{description}


\chapter{Language Toolkit for Processor Based Refactoring}
For our refactoring Plugin we used the Processor based refactoring, offered by the Language Toolkit of Eclipse. 

\chapter{Menu's with conditional visibility}

3x new method:
getInternalyUnusedDeclarations
isModifying(Identifier) checks if the Identifier is modified in the Codeblock
getPotentionalyChangedVariables

\part{The Refactoring Plugin Software}
\chapter{The general refactoring life cycle}
From a user perspective the general refactoring life cycle looks like this:
   \begin{enumerate}
     \item The user selects a new text range in his nesc editor.
     \item Eclipse instantiates a {\it RefactoringAvailabilityTester} which is a subtype of {\it PropertyTester} defined by eclipse.
     \item Eclipse checks all refactorings defined in the {\it plugin.xml} against the property tester, and memorises which of them are available. 
     \item Eclipse shows the available refactorings in the top menu bar, as well as in the popup menu.
     \item The user selects a refactoring, which he wants to execute.
     \item Eclipse will execute the appropriate action handler.
     \item The user probably has to do some input.
     \item Eclipse finishes the refactoring.
   \end{enumerate}
This life cycle can be divided in two main parts. The first part is the evaluation of the available refactorings and the second part is the actual execution of a specific refactoring. 
This partitioning has two major advantages. First it allows a better user experience, since he sees only the refactorings, which are really executable for the current selection. 
Second, the execution of a refactoring no more has to care about, if the refactoring is even available.

\chapter{From Plugin XML to Java Code}
\section{How to decide the availability of a refactoring}
After we have introduced the appropriate lines of XML in the {\it plugin.xml} for a specific refactoring, the plugin is now able to ask the question: ``Is the current selection appropriate for this refactoring?''
But the software is not yet capable to answer this question. That is where the {\it Refactoring} enum and the {\it RefactoringAvailabilityTester} come in.

\subsection{The {\it Refactoring} enum}
The {\it Refactoring} enum defines for each refactoring, which is defined in the {\it plugin.xml}, its corresponding counterpart in java code as an enum constant.
Every such enum constant has three fields:
   \begin{enumerate}
     \item {\it propertyName} of type {\it String}
     \item {\it entityName} of type {\it String}
     \item {\it tester}  of type {\it IRefactoringAvailabilityTester}
   \end{enumerate}
The {\it propertyName} string must match exactly the string, which is given in the {\it plugin.xml} as property name for the refactoring. 
It is later on used, to direct the question, if a selection is appropriate for a specific refactoring, to the right answer.\\
The {\it entityName} string is used only to output information to the user. It is intended to designate the entity, which is modified by the refactoring. I.e. the entity name could be ``function'', if the refactoring is about renaming a function, or ``alias``, if the refactoring introduces a new alias.\\
The {\it tester} field contains for each refactoring an instance of type {\it IRefactoringAvailabilityTester}. This instance is the one which will finally answer the question, if the refactoring is available for the current selection.

\subsection{The {\it RefactoringAvailabilityTester} class}
The {\it RefactoringAvailabilityTester} is the class, which is designated in the {\it plugin.xml} as the property tester. This means that for every refactoring, which is defined in the {\it plugin.xml},
eclipse will ask an instance of this class, if the refactoring is available for the current selection. Eclipse does so by calling the function {\it test} of {\it RefactoringAvailabilityTester}. 
Everytime the user changes the selection in the editor, one such call is executed for every defined refactoring.
The declaration of this function is actually inherited from the abstract supertype {\it PropertyTester}, which is a class defined by Eclipse.\\
The {\it test} function has a return value of type {\it boolean} and four parameters:
   \begin{enumerate}
     \item {\it receiver} of type {\it Object}
     \item {\it property} of type {\it String}
     \item {\it args}  of type {\it Object[]}, we do not make use of this parameter.
     \item {\it expectedValue}  of type {\it Object}, we do not make use of this parameter.
   \end{enumerate}
The {\it receiver} parameter must be an instance of type {\it ITextSelection}, since the property tester is configured like that in the {\it plugin.xml}. This instance contains information about the range of the current selection.\\
The second parameter of the {\it test} function is of type {\it String} and is named {\it property}. During a call this will be one of the strings, which we have defined in the {\it plugin.xml}, for a specific refactoring.\\
The {\it test} function now first checks if the plugin is even fully loaded at this point. If we would not do this check, it could be that not all information are available in a refactoring processor, which are assumed to be always available. This would lead to unexpected behaviour.
If this check fails the function just returns false, which means  that there will be no refactoring available.\\
If the plugin is fully loaded, we come now to the point where the real matching from XML to java code happens. The {\it test} function looks for the {Refactoring} enum constant, whichs {\it propertyName} string matches the {\it property} string passed as an argument.
If there is no such enum constant, then either the programmer forgot to define the corresponding enum constant, for a refactoring defined in the {\it plugin.xml}, or the {\it propertyName} and the {\it property} strings are not equal, i.e. if there is a typo in one of them.\\
If we now have the {\it Refactoring} enum constant for a given {\it property} string, then we can read out its {\it tester} field. This gives us an instance of type {\it IRefactoringAvailabilityTester} and we can execute a call to the function {\it test} of this instance.
This function will return true, if this refactoring is available and false otherwise. This return value is also the appropriate return value for our {\it test} function of the {\it RefactoringAvailabilityTester}.

\subsection{The {\it IRefactoringAvailabilityTester} interface}
Each refactoring has 

\nomenclature{OSGi}{The OSGi framework is a module system and service platform for the Java programming language that implements a complete and dynamic component model, something that does not exist in standalone Java/VM environments. Applications or components (coming in the form of bundles for deployment) can be remotely installed, started, stopped, updated and uninstalled without requiring a reboot; management of Java packages/classes is specified in great detail. Life cycle management is done via APIs which allow for remote downloading  of management policies. The service registry allows bundles to detect the addition of new services, or the removal of services, and adapt accordingly. (from Wikipdedia)}
\renewcommand{\nomname}{Glossary}
\printnomenclature

\end{document}          
