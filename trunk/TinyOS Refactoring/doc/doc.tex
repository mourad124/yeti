\documentclass[a4paper,10pt]{report}
\usepackage[utf8x]{inputenc}

% Code Listings
\usepackage{listings,color} 
\lstset{numbers=left, numberstyle=\tiny, numbersep=5pt,basicstyle=\footnotesize,breaklines=true} 
\lstset{language=Java}

% Glossary
\usepackage{nomencl}
\makenomenclature

% Allow Hyperlinks in the PDF
\usepackage{hyperref}  
\hypersetup{colorlinks=false,
            pdftitle={Refactoring extension for the Yeti NesC Eclipse plug-in},
            pdfauthor={Noah Heusser, Max Urech},
            pdfsubject={Documentation of the refactoring extenstion for the Yeti NesC Eclipse Plugin},
            pdfkeywords={Refactoring, NesC, Yeti, TinyOS, Eclipse, LTK, Language Toolkit, ETH},
            pdfborder={0 0 0}
} 

% Grafics
\usepackage{graphicx}
\usepackage[dvipdfm]{geometry}

% Title Page
%\title{Refactoring extenstion for the Yeti NesC Eclipse plug-in}
%\author{Noah Heusser, Max Urech}
\begin{document}
\begin{titlepage}
\begin{center}
\includegraphics[width=.95\textwidth]{titelblatt.png}
\end{center}
\end{titlepage}


\begin{abstract}
In today's software development processes agile development is the state of the art. Agile processes lead to frequent code reorganizations or in one words ``Refactoring''.
Refactoring can be a lot of boring and error-prone work if a developer has to do it by hand. One can easy see that a computer is much faster and far more reliable if it comes to finding all occurs of a variable name and change them to a new name.

A refactoring plug-in like the one we wrote allows the software developer to concentrate on the design of the software and let the computer do the busy work. This document describes the used frameworks and explains the solution we developed.

After all today we have a working refactoring plug-in which allows to rename most elements of the NesC language. We could also introduce some other refactorings like 
``Introduce Alias'' or ``Extract Function'', but in this area a lot of work could still be done.

We hope you enjoy using our software and also the reading of this document. 
\end{abstract}

\tableofcontents

\part{What is refactoring}
\chapter{Definition of refactoring}
Wikipedia gives us the following definition for code refactoring:
``Code refactoring is the process of changing a computer program's source code without modifying its external functional behavior in order to improve some of the nonfunctional attributes of the software. 
Advantages include improved code readability  and reduced complexity to improve the maintainability of the source code, as well as a more expressive internal architecture or object model to improve extensibility.''
Since this document is about a refactoring facility for NesC, we are of course actually always referring to code refactoring, when we talk about refactoring.

\chapter{Why do we need refactoring}
Reusability and maintainability are two terms, which are known to everybody, who ever heard something about software engineering. 
A refactoring facility is a means for supporting those properties. I.e. if you want to reuse an existing function in a program in a second place,
you might suddenly realise, that the name of the function actually not really matches its purpose and you consequently want to rename it to a more appropriate name.
If you have a function rename refactoring at hand at this point, you simply have to select the refactoring, type in the name, press enter and you are done. 
Without such a tool you had to replace the function name by hand at every position in the program, where it appears, possibly in different files.
This example is also good for the cast, that refactoring supports maintainability, because a readable program is also a maintainable program. 
And if the names of the different entities in a program match their purpose, the program is for sure more readable, then if they don't.

\part{Eclipse plug-ins}
\chapter{General info about writing plug-ins}
Eclipse is famous for its plug-in architecture. Everything in Eclipse is a plug-in. An Eclipse plug-in is a JAR-File or a folder in the plugins-Directory of the Eclipse program folder.
To be a plug-in it takes at least three files.
\begin{itemize}
  \item META-INF/MANIFEST.MF
  \item plugin.xml
  \item plugin.class
\end{itemize}

\section{META-INF/MANIFEST.MF}
The Manifest file is the first file that is read by Eclipse while loading the plug-in. It contains all the information's about what requirements 
are needed to load the plug-in and how it can be loaded. I will now explain the most important entry's in the Manifest file.

\begin{lstlisting}[caption=MANIFEST]{META-INF/MANIFEST.MF}
Manifest-Version: 1.0
Bundle-ManifestVersion: 2
Bundle-Name: TinyOS_Refactoring
Bundle-SymbolicName: tinyos.yeti.refactoring;singleton:=true
Bundle-Version: 1.0.0
Bundle-Activator: tinyos.yeti.refactoring.RefactoringPlugin
Require-Bundle: org.eclipse.ui,
 org.eclipse.core.runtime,
 tinyos.yeti.core;bundle-version="2.2.17",
 tinyos.yeti.parser.nesc12;bundle-version="1.2.17",
 org.eclipse.ui.workbench.texteditor;bundle-version="3.5.1",
 org.eclipse.ltk.core.refactoring;bundle-version="3.5.0",
 org.eclipse.ltk.ui.refactoring;bundle-version="3.4.101",
 org.eclipse.core.resources;bundle-version="3.5.2",
 org.eclipse.jface.text;bundle-version="3.5.2",
 org.eclipse.ui.ide;bundle-version="3.5.2",
 org.eclipse.ui.editors;bundle-version="3.5.0",
 tinyos.yeti.preprocessor.nesc12;bundle-version="1.2.17",
 org.eclipse.core.expressions;bundle-version="3.4.101"
Bundle-ActivationPolicy: lazy
Bundle-RequiredExecutionEnvironment: JavaSE-1.6
\end{lstlisting}


\begin{description}
 \item[Manifest-Version] This line shows that a manifest's entries take the form of "header: value" pairs. The name of a header is separated from its value by a colon. (from \href{ http://java.sun.com/developer/Books/javaprogramming/JAR/basics/manifest.html}{ http://java.sun.com/developer/Books/javaprogramming/JAR/basics/manifest.html} access 2.9.2010)
 \item[Bundle-ManifestVersion] Manifest header identifying the bundle manifest version. A bundle manifest may express the version of the syntax in which it is written by specifying a bundle manifest version. Bundles exploiting OSGi Release 4, or later, syntax must specify a bundle manifest version. 
The bundle manifest version defined by OSGi release 4 or, more specifically, by version 1.3 of the OSGi core specification is "2". (from Eclipse Help Version: 3.5.2)
 \item[Bundle-Name] A human readable meaningful name for the plug-in you write.
 \item[Bundle-SymbolicName] A unique string identifier for you plug-in. Mostly the path of your package structure is used. The {\it singelton:=true} makes the OSGi Framework only load your plug-in once. It has to be set in every Eclipse plug-in. It is only necessary because Eclipse uses OSGi which is not only used for Eclipse.
 \item[Bundle-Version] Defines the Version of the plug-in. When the plug-in is used by an other plug-in, it can specify the version in the {\it Required-Bundle} parameter. A version is composed of 3 positive natural numbers and a string separated by ``.'' sign. Two versions are equal if the numbers are equal. The string in the end might be used to specify different versions with the absolute same interface (for example different compilers). The numbers from left to right are called: Major.Minor.Mirco.
 \item[Bundle-Activator] This is the path of the class which is used to start the whole plug-in. The class must extend {\it org.eclipse.core.runtime.Plugin}. 
 \item[Require-Bundle] When you write you plug-in you will use the Functionality of other plug-ins. To do that you have to specify here which plug-ins you use. Eclipse will refuse to load your plug-in if the plug-ins you require are not available. In addition you can specify the version of the plug-in you need to be available. If you don't specify anything else Eclipse will assume to have a compatible version as long as there is one having the same Major-Number. In case of you have to be pickier, you can also add a {\it match} parameter with {\it perfect} for Major, Minor and Micro number have to match, or {\it equivalent} for Major and Minor Number have to match.
 \item[Bundle-ActivationPolicy] The only parameter you can add here is {\it lazy} which tells OSGi to wait with loading the plug-in until it is used.
 \item[Bundle-RequiredExecutionEnvironment] Defines a lower bound for the version of the JVM that is allowed to be used.
 \end{description}

\section{plugin.xml}
The {\it plugin.xml} file was once responsible for all the things that are now configured in the {\it MANIFEST.MF} file. If you search the Internet you will have problems to find what you are looking for cause of that. Today the {\it plugin.xml} is responsible for offering and using extension points. I will not talk about how to offer an extension point, cause for this project it wasn't used.

\subsection{Using extension points (making extensions)}
When you want to use an extension point, you have to add the plug-in which defines the extension point to you {\it Require-Bundle} list in the {\it MANIFEST.MF}. Mostly you will have found the extension point you want to use by Google and often you don't know what plug-in is offering that extension point. The only advice I can give you is to use Google again or grep throw the plug-ins directory of Eclipse. We did not find a way in which one could easily find the right plug-in.

When the right plug-ins are included, one can use the extension points by adding a {\it $<$ extension$>$} tag.
\begin{lstlisting}[language=XML,caption=Use extenstion point ({\it plugin.xml})]{plugin.xml}
<?xml version="1.0" encoding="UTF-8"?>
<?eclipse version="3.4"?>
<plugin>
 	<extension 
	    point="org.eclipse.core.expressions.propertyTesters">
   		<propertyTester ... />
 	</extension>
</plugin>
\end{lstlisting}

The {\it $<$extenstion$>$} tag has only one important attribute. It is the extension point you want to use. In this case of our example we use the extension point {\it propertyTesters} offered by the plug-in {\it org.eclipse.core.expressions}.

The tags between {\it $<$extension$>$} and {\it $<$/extension$>$} are information's for the extension point. What tags need to be there can be read in the XML-Schema file in the {\it org.eclipse.core.expressions} plug-in Jar. I won't go into detail here, but the {\it plugin.xml} of the plug-in that provides the extension point defines where in the Jar the Schema file is. Eclipse can show the Schema file by clicking on {\it Show extension point description} in the {\it Extention}-Tab of the {\it plugin.xml} editor.

Important is to understand how Eclipse calls your code. First you find the extension point you want to extend. Then you write your XML code to extend it. For some extension points a class, implementing an interface has to be passed as attribute. If so the extension point loads your class and executes a method of that interface.


\chapter{Language Toolkit for processor based refactoring}
\label{languageToolkitForProcessorBasedRefactoring}
For our refactoring plug-in we used the processor based refactoring, offered by the Language Toolkit of Eclipse. We will explain now how such a refactoring works.
\section{Important classes}
\label{languageToolkitClasses}
\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{classDiagrammProcessorBasedRefactoring.png}
\end{figure}

In the class diagram the most important classes are shown. While writing refactorings you won't have to care about the classes {\it RefactoringWizardOpenOperation}, {\it Refactoring} and {\it ProcessorBasedRefactoring}. This 
classes can be used as they are. All the other classes need to be extended.
\begin{description}
 \item[RefactoringWizard] When the user starts a refactoring he is asked for additional information's. This form is painted by the {\it RefactoringWizard} class.
The connection to the Info class is necessary to store the information's the user typed into the form. 
 \item[RefactoringInfo] The {\it RefactoringInfo} class is not a class of the LTK framework, we introduced it to allow communication between the {\it RefactoringProcessor} and the {\it RefactoringWizard}. 
The idea to do it that way is from the Article \href{http://www.eclipse.org/articles/Article-LTK/ltk.html}{http://www.eclipse.org/articles/Article-LTK/ltk.html}. When writing Refactorings for our Project, you can extend the 
{\it RefactoringInfo} class. It supports already some utility functionality.
 \item[RefactoringProcessor] This class does the actual Refactoring. 
\begin{description}
 \item[isApplicable()] This method checks if the refactoring can be used. It can be used to enable or disable menu entry's. During my work with the refactoring processor, this 
method got never called by the Framework. It can easily be implemented by calling {\it checkInitialConditions()}.
\begin{lstlisting}[caption=Generic isApplicable Implementation]{PropertyTester.java}
public boolean isApplicable() throws CoreException {
  return checkInitialConditions(new NullProgressMonitor()).
           hasFatalError();
}
\end{lstlisting}
\item[identifyer] A unique identifier for the processor.
\item[name] A human readable name for what the refactoring does.
\item[checkInitialConditions] Checks whether the refactoring is applicable before the user gives any information's about how the refactoring should happen. Mostly we checked
here if the user did a valid selection. For the conditional visibility we used, it was used to decide whether a refactoring is offered or not.
The return value is a status. If the refactoring can not be executed, the status must contain fatal errors. Otherwise the refactoring is meant to be executable.
\item[checkFinalConditions] Checks whether the information's the user gave to configure the refactoring are valid. 
\item[createChange] This is the method where the magic happens. All the changes of your refactoring are made within this method. The return value is a {\it Change}. A {\it Change}
describes what you want to change in your refactoring. You don't execute the change yourself, this is done by the framework. LTK offers a lot of implementations of the {\it Change}
class. 
\end{description}
\end{description}

\section{The {\it Change} classes}
The LTK offers the {\it Change} class. By creating {\it Change} classes in stead of doing the changes yourself you allow LTK to provide ``change preview functionality''.
LTK offers a lot of changes for moving, renaming and so forth. I just talk about the most important ones.
\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{changeClassDiagramm.png}
\end{figure}
\begin{description}
 \item[CompositeChange] Most refactorings change more than one thing. That's way you will use this {\it Change} in almost every refactoring.
 \item[NullChange] A {\it Change} that does nothing. It allows you to avoid null-values within your Code.
 \item[DocumentChange] Changes a text file which is opened in the editor. It allows you to change code that has not yet been saved. We wanted to use this, but got 
Exceptions cause Threads tried to access data that are not allowed to be accessed by them. In the Internet we found people having the same problem, but no solution. The problem seems
to occur only in the newest version of Eclipse. Maybe it is solved when you read this. If so, use this Change for files that are opened, and not {\it TextFileChange}.
 \item[TextFileChange] We used the {\it TextFileChage} to do all our text changes. It works, but the User is forced to save all files before he can start doing 
refactoring. 
\end{description}



\section{Refactoring operation sequence}
\label{refactoringOperationSequence}
Now you know all the classes. I will no outline what happen when a refactoring takes place. 
\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{interactionDiagramRefactoring.png}
\label{ interactionDiagramRefactoring }
\end{figure}
First, (not in picture \ref{ interactionDiagramRefactoring }) the user starts a refactoring by clicking on a menu entry. The {\it ActionHandler} gets called and initializes all necessary classes.
You can see that the {\it RefactoringWizard} and the {\it RefactoringProcessor} both get a link to the {\it Info} Object. If you are working with the selection, save
the selection to the {\it Info} Object in the ActionHandler, later it is hard, cause you are in the wrong thread.

Then the {\it ActionHandler} calls the {\it run()} method of the {\it RefactoringWizardOpenOperation}. I have to say that the calls which are done by the
{\it RefactoringWizardOpenOperation} are not really done by the {\it RefactoringWizardOpenOperation} class. But it would become very complex to explain how it really works.
The effect you see when your methods are called is as in the picture.

The {\it RefactoringWizardOpenOperation} checks if the initial conditions are OK. If not it would show the status error message to the user and terminate. If there
are no fatal errors, the {\it RefactoringWizard} is called to draw the form and save the necessary information's of the users to the {\it Info} object.

Now, the final conditions can be checked by the {\it RefactoringProcessor}. If they are not OK, the status errors will be shown to the user and the {\it RefactoringWizard}
will be shown again. If they are OK, the {\it createChange()} method of the {\it RefactoringProcesser} gets called. A preview of the changes is shown to the user.

If the user accepts the changes, they get applied and the Refactoring is finished. During the whole Process, LTK makes sure that the user has {\it back} and {\it cancel} buttons.

\chapter{Menu's with conditional visibility}
\label{menuWithConditionalVisibility}
In our plug-in the use case is always the same. The user selects some code, the user selects a refactoring, the user executes the refactoring. To achieve that we need to have menus where the user can select the refactoring he wants to execute.
But this is not enough, our plug-in supports a lot of Refactorings. If the User has to find the Refactoring he wants to use in a list of all possible refactorings, it will take him a lot of time.
To make it easy for the user we want to list only those refactorings that are actually possible for his momentary selection. This means we need conditional visibility.

In the picture \ref{menuStructure} the necessary components for a menu with conditional visibility are shown. During the following sections we will explain every component in the picture \ref{menuStructure}.
\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{menuStructure.png}
\label{menuStructure} 
\end{figure}

\section{Create a menu entry}
Eclipse knows about a hundred ways to create a new menu entry. Almost none of them make it necessary to write Java code, but all of them have different possibilities. 
During our project we were not able to understand what ways are deprecated or what the today's state of the art way is. After testing three ways which did not fit our needs,
we chose the one we will explain now. 

\subsection{Add a new submenu}
We want our refactoring functionality to be available in two menus. In the main menu of the Eclipse window and the context menu which appears when one right clicks on
a selection. To do that we used the {\it org.eclipse.ui.menus} extension point. In this extension point every menu can be identified by a URI. The URI of the main menu is:
{\it menu:org.eclipse.ui.main.menu} and to define it's position we add {\it ?after=additions} to the URI. This adds the menu just after the menus of the additions group, 
which is the core functionality of the Eclipse IDE. In the UML this {\it $<$menu$>$} Tag is the {\it MenuContributionMenu} class.

In XML code it looks like this:
\begin{lstlisting}[language=XML,caption=Create menu folder ({\it plugin.xml})]{plugin.xml}
<extension id="add.item" point="org.eclipse.ui.menus">
  <-- Entrys in the Top Menu -->
  <menuContribution
     locationURI= "menu:org.eclipse.ui.main.menu?after=additions">
    <menu id="tinyos.yeti.RefactoringMenu"
          label="Refactoring" />
  </menuContribution>
</extenstion>
\end{lstlisting}
Important is to see that we use the tag {\it $<$menu$>$} which means that we add a submenu and the id of the new submenu is {\it tinyos.yeti.RefactoringMenu}. 
Later when we add commands to that submenu we have to refer to that id.

To add the submenu to the context menu too, we add the same XML block again, but use the URI {\it popup:org.eclipse.ui.popup.any} and give it the id {\it tinyos.yeti.RefactoringPopup}.

If you would now start Eclipse with that new menu, you wouldn't see anything. The submenus are only displayed if the submenu are not empty.
\subsection{Add a command to the submenu}
Adding a command (an entry which triggers an action) is also done by the tag {\it $<$menuContribution$>$} but this time not by the child tag {\it $<$menu$>$} but {\it $<$command$>$}.
In the UML diagram we called it {\it MenuContributionCommand}. For now we don't look at the {\it visibleWhen}, it will be explained later.

The {\it $<$command$>$} tag has three attributes. {\it lable} is the string the user will see in the menu. {\it id} is just a unique identifier and {\it commandId} is the 
id of the command that shell be executed when the user clicks on this entry. Creating that command will be explained in the next section.

In XML it looks like this:
\begin{lstlisting}[language=XML,caption=Adding a command to a menu ({\it plugin.xml})]{plugin.xml}
<extension id="add.item" point="org.eclipse.ui.menus">
  <menuContribution
       locationURI= "menu:tinyos.yeti.RefactoringMenu?after=additions">
    <command commandId="tinyos.yeti.refactoring.rename.local.variable"
             id= "RenameLocalVariable"
             label= "Rename Local Variable" />
  </menuContribution>
</extension>
\end{lstlisting}
You can see that the {\it menuContribution} goes this time to {\it tinyos.yeti.RefactoringMenu} which we defined in the last section.

\subsection{Createing a command}
This is now the command that is called command in the UML diagram. It is not in the extenstion point {\it org.eclipse.ui.menus} but in the extenstion point {\it org.eclipse.ui.commands}. 
The {\it $<$command$>$} tag has three attributes. An {\it id} which is a unique identifier. The {\it categoryId} which groups the the {\it $<$command$>$}'s to categories.
We never used the Categories so we just introduced one and gave all our commands this category. We hoped that it would be possible to fill a submenu with a category of commands.
But we didn't find a way to achieve that. The third parameter is a {\it name}. We never used it either, we usually took the label in the menu also as name of the command.

In XML it looks like this:
\begin{lstlisting}[language=XML,caption=Createing a command ({\it plugin.xml})]{plugin.xml}
<extension point="org.eclipse.ui.commands">
  <category id="tinyos.yeti.refactoring"
            name="Refactoring" />
  <command id="tinyos.yeti.refactoring.rename.local.variable"
           categoryId="tinyos.yeti.refactoring"
           name="Rename Local Variable"/>
</extension>
\end{lstlisting}

One can ask now, where does Eclipse know from what method it has to invoke to call that command. Well it does not. To know that, we have to define a {\it handel}.

\subsection{Introducing a handler for a command}
\label{commandHandler}
A handler is connects a command in the XML file to a Java class which implement the interface {\it org.eclipse.core.commands.IHandler}. The extension point
{\it org.eclipse.ui.handlers} helps doing that job. It is very simple. Just the {\it class} and the {\it commandId}.
\begin{lstlisting}[language=XML,caption=Connecting a command to a handler ({\it plugin.xml})]{plugin.xml}
<extension point="org.eclipse.ui.handlers">
   <handler class="tinyos.yeti.refactoring.entities.variable.rename.local.RenameLocalVariableActionHandler"
            commandId="tinyos.yeti.refactoring.rename.local.variable" />
</extention>
\end{lstlisting}

\subsection{Bindings}
We did not yet speak about bindings. They allow you to introduce shortcuts for your commands. We did it first, but removed it later again.
We think the following code explains itself:
\begin{lstlisting}[language=XML,caption=Introduce shortcuts ({\it plugin.xml})]{plugin.xml}
<extension point="org.eclipse.ui.bindings">
                <!--
                        One could also add a Shortcut, by adding the following Attribute
                        to the <key>-Tag,
                        for example: sequence="M1+M2+r"

                        The M Keys in the sequence are Platform independent keys.
                                On PCs they are mapped to:
                M1 = Ctrl
                M2 = Shift
                M3 = Alt

                The upper example would the the shortcut: Ctrl+Shift+r
		-->
                <key commandId="tinyos.yeti.refactoring.rename.local.variable"
                     schemeId="org.eclipse.ui.defaultAcceleratorConfiguration"
                     sequence="M1+M2+r" />
</extenstion>
\end{lstlisting}

\section{Add conditional visibility}
\label{conditionalVisibility}
Up to now all our menu entries will always be available no matter whether the user did a valid selection or not. But in the beginning of this chapter we decided to show only 
those refactorings that are executable for the momentary selection.
\subsection{Property tester}
To do that we use the extension point {\it org.eclipse.core.expressions.propertyTesters}. It allows defining a {\it propertyTester} with a list of properties. In our
case we defined one {\it propertyTester} called {\it tinyos.yeti.refactoring.AvailabilityTester} which has one property for each Refactoring.

In XML:
\begin{lstlisting}[language=XML,caption=Property tester ({\it plugin.xml})]{plugin.xml}
<extension point="org.eclipse.core.expressions.propertyTesters">
  <propertyTester id="tinyos.yeti.refactoring.AvailabilityTester"
                  type="org.eclipse.jface.text.ITextSelection"
                  namespace="tinyos.yeti.refactoring.isAvailable"
                  properties="renameLocalVariable, ..."
                  class="tinyos.yeti.refactoring.AvailabilityTester" />
</extension>
\end{lstlisting}

One can see that is has a {\it class} parameter. This is a Java class that extends {\it org.eclipse.core.expressions.PropertyTester}. It has only one abstract method:
\begin{lstlisting}[caption=extends PropertyTester]{PropertyTester.java}
public class AvailabilityTester extends PropertyTester {

  public boolean test(Object receiver, String property, Object[] args,Object expectedValue) {
    
  }
}
\end{lstlisting}
One can see that there is a string {\it property}. It is exactly the String that is defined in the {\it property} attribute of the {\it propertyTester} tag.
This way we wrote for each refactoring a test whether it is available or not.

\subsection{Visibility Condition}


\begin{lstlisting}[language=XML,caption=Visibility condition ({\it plugin.xml})]{plugin.xml}
<extension id="add.item"
           point="org.eclipse.ui.menus">
  <menuContribution locationURI= "menu:tinyos.yeti.RefactoringMenu?after=additions">
    <command commandId="tinyos.yeti.refactoring.rename.local.variable"
             id= "RenameLocalVariable"
             label= "Rename Local Variable">
      <visibleWhen checkEnabled="false">
        <iterate ifEmpty="false">
          <!-- The forcePluginActivation-Parameter is absolutly necessary. 
               Otherwise the Property gets never checkt -->
          <test property="tinyos.yeti.refactoring.isAvailable.renameLocalVariable"
                forcePluginActivation="true" />
        </iterate>
      </visibleWhen>
    </command>
  </menuContribution>
</extenstion>
\end{lstlisting}
In the {\it MenuContributionCommand} we add a {\it visibleWhen} tag. The {\it checkEnabled="false"} disables the check whether the Command is available or not. 
It is a functionality provided by the handler class. Technically it would work with just writing {\it checkEnabled="true"} and implementing the functionality in 
the {\it ActionHandler}. But as the name {\it isEnabled} says, it is not the idea of this function. That's way we preferred doing it with the property.

The {\it visibleWhen} is necessary cause it seems to be a collection that we get there. If the tag is not there it won't work.

\part{The Refactoring Plugin}
\chapter{About our plugin}
The refactoring plugin is an extension for the Eclipse Yeti plugin. Its target is to accelerate the development of NesC code and make it more convenient.
This is achieved by automating low level, time consuming tasks.
\section{The general refactoring life cycle}
From a user perspective the general refactoring life cycle looks like this:
   \begin{enumerate}
     \item The user selects a new text range in his nesc editor.
     \item Eclipse instantiates a {\it RefactoringAvailabilityTester} class, which is a subtype of the {\it PropertyTester} class, which is defined by Eclipse.
     \item Eclipse checks all refactorings defined in the {\it plugin.xml} against the property tester, and memorises which of them are available. 
     \item Eclipse shows the available refactorings in the top menu bar, as well as in the popup menu.
     \item The user selects a refactoring, which he wants to execute.
     \item Eclipse will execute the appropriate action handler.
     \item The user probably has to do some input.
     \item Eclipse shows the changes to be done in a preview window.
     \item The user confirms or denies the changes.
     \item Eclipse finishes the refactoring.
   \end{enumerate}
This life cycle can be divided in two main parts. The first part is the evaluation of the available refactorings and the second part is the actual execution of a specific refactoring. 
This partitioning has two major advantages. First it allows a better user experience, since he sees only the refactorings, which are really executable for the current selection. 
Second, the execution of a refactoring does not have to care, if the refactoring is applicable.\\
In the graphic on page \pageref{UserInputSequence} you can see the steps the user has to take in order to execute a refactoring.

\newpage
\begin{figure}[h]
\centering
\includegraphics[height=0.98\textheight]{userInputSequence.png}
\caption{A standard user interaction with the refactoring plugin.}
\label{UserInputSequence}
\end{figure}

\section{Package structure}
The root package of the plugin is {\it tinyos.yeti.refactoring}. It contains the {\it RefactoringPlugin} class, which is required for an Eclipse plugin, as well as the classes we gone talk about in the chapter "From plugin XML to java code".\\
The root package contains four subpackages:
   \begin{enumerate}
     \item The {\it abstractrefactorings} package
     \item The {\it ast} package
     \item The {\it utilities} package
     \item The {\it entities} package
   \end{enumerate}
The {\it abstractrefactorings} package contains infrastructure classes, used to implement concrete refactorings. We take a closer look at this classes in the "Abstract refactorings" chapter.\\
The {\it ast} and {\it utilities} packages include classes, which are used to interact with the AST and the project, in which we are doing refactoring. The contents of this packages are explained in the chapter "Harnessing the AST".\\
The {\it entities} package is actually the root package for all concrete refactoring implementations. By entity we mean an object which can be modified by a refactoring. I.e. the entity of a rename or extract function refactoring is a function. The entity of a rename or introduce interface alias is an interface alias.
Therefore the next level of packages in the {\it entities} package will designate a entity, and the package in such a specific package will designate a concrete refactoring. This means that you will find the concrete implementation of the rename interface alias refactoring implementation in the subpackage {\it entities.interfaces.alias.rename}.
About concrete refactorings we will talk in the chapter "Concrete refactorings".


\chapter{From plugin XML to Java code}
\label{fromPluginXMLToJavaCode}
\section{How to decide the availability of a refactoring}
After we have introduced the appropriate lines of XML in the {\it plugin.xml} for a specific refactoring, the plugin is now able to ask the question: ``Is the current selection appropriate for this refactoring?''
But the software is not yet capable to answer this question. That is where the {\it Refactoring} enum and the {\it RefactoringAvailabilityTester} come in. 
An overview of the relations described in this chapter is given in the graphic on page \pageref{AvailabilityTesterContext}.

\begin{figure}[h]
\centering
\includegraphics[height=.5\textheight]{AvailabilityTesterContext.png}
\caption{The {\it RefactoringAvailabilityTester} class and its context}
\label{AvailabilityTesterContext}
\end{figure}

\subsection{The {\it Refactoring} enum}
The {\it Refactoring} enum defines for each refactoring, which is defined in the {\it plugin.xml}, its corresponding counterpart in java code as an enum constant.
Every such enum constant has three fields:
   \begin{enumerate}
     \item {\it propertyName} of type {\it String}
     \item {\it entityName} of type {\it String}
     \item {\it tester}  of type {\it IRefactoringAvailabilityTester}
   \end{enumerate}
The {\it propertyName} string must match exactly the string, which is given in the {\it plugin.xml} as property name for the refactoring. 
It is later on used, to direct the question, if a selection is appropriate for a specific refactoring, to the right answer.\\
The {\it entityName} string is used only to output information to the user. It is intended to designate the entity, which is modified by the refactoring. I.e. the entity name could be ``function'', if the refactoring is about renaming a function, or ``alias``, if the refactoring introduces a new alias.\\
The {\it tester} field contains for each refactoring an instance of type {\it IRefactoringAvailabilityTester}. This instance is the one which will finally answer the question, if the refactoring is available for the current selection.

\subsection{The {\it RefactoringAvailabilityTester} class}
The {\it RefactoringAvailabilityTester} is the class, which is designated in the {\it plugin.xml} as the property tester. This means that for every refactoring, which is defined in the {\it plugin.xml},
eclipse will ask an instance of this class, if the refactoring is available for the current selection. Eclipse does so by calling the function {\it test} of {\it RefactoringAvailabilityTester}. 
Everytime the user changes the selection in the editor, one such call is executed for every defined refactoring.
The declaration of this function is actually inherited from the abstract supertype {\it PropertyTester}, which is a class defined by Eclipse.\\
The {\it test} function has a return value of type {\it boolean} and four parameters:
   \begin{enumerate}
     \item {\it receiver} of type {\it Object}
     \item {\it property} of type {\it String}
     \item {\it args}  of type {\it Object[]}, we do not make use of this parameter.
     \item {\it expectedValue}  of type {\it Object}, we do not make use of this parameter.
   \end{enumerate}
The {\it receiver} parameter must be an instance of type {\it ITextSelection}, since the property tester is configured like that in the {\it plugin.xml}. This instance contains information about the range of the current selection.\\
The second parameter of the {\it test} function is of type {\it String} and is named {\it property}. During a call this will be one of the strings, which we have defined in the {\it plugin.xml}, for a specific refactoring.\\
The {\it test} function now first checks if the plugin is even fully loaded at this point. If we would not do this check, it could be that not all information are available in a refactoring processor, which are assumed to be always available. This would lead to nondeterministic behaviour.
If this check fails the function just returns false, which means  that there will be no refactoring available. Furthermore there is a check, if all source files are saved. If there are modified ones, the function returns true only for the {\it NotSaved} property. 
If this is the case, the user can save all modified files with a click on a button under the refactoring menu. \\
If the plugin is fully loaded, we come now to the point where the real matching from XML to java code happens. The {\it test} function looks for the {Refactoring} enum constant, whichs {\it propertyName} string matches the {\it property} string passed as an argument.
If there is no such enum constant, then either the programmer forgot to define the corresponding enum constant, for a refactoring defined in the {\it plugin.xml}, or the {\it propertyName} and the {\it property} strings are not equal, i.e. if there is a typo in one of them.\\
If we now have the {\it Refactoring} enum constant for a given {\it property} string, then we can read out its {\it tester} field. This gives us an instance of type {\it IRefactoringAvailabilityTester} and we can execute a call to the function {\it test} of this instance.
This function will return true, if this refactoring is available and false otherwise. This return value is also the appropriate return value for our {\it test} function of the {\it RefactoringAvailabilityTester}.

\subsection{The {\it IRefactoringAvailabilityTester} interface}
Each refactoring has an instance of type {\it IRefactoringAvailabilityTester} assigned to it. This assignment is done in the {\it Refactoring} enum. This interface has a single function {\it test}, with a return value of type {\it boolean}, and a single parameter {\it selection} of type {\it ITextSelection}.
The purpose of the function is to decide, if the current selection is a selection, which is appropriate for the specific refactoring to be executed. If it is, the function will return true and false otherwise.\\
To find this decision, the refactoring can make use of the class {\it ActionHandlerUtil} to gain access to further information, i.e. to get the selected editor, or the selected file.\\


\section{How to execute a specific refactoring}
At this point Eclipse knows, which refactorings are available for the current selection. Now the refactoring has to be executed, if the user clicks on the corresponding button in the refactoring top menu, or the popup menu of Eclipse.
Behind this buttons sits an implementation of the {\it AbstractHandler} abstract class. This class is defined by Eclipse. For each refactoring such an implementation has to be defined in the {\it plugin.xml}. Thats how a refactoring is mapped to its execution.

\subsection{The {\it AbstractHandler} abstract class}
This class is defined by eclipse as an abstract class. For our implementations there is only the function {\it execute} of interest. This function is declared abstract in the {\it AbstractHandler} class and therefore has to be implemented in its subtypes.\\
This function is actually the place, where the Language Toolkit for Processor Based Refactoring goes into action. Here will the wizard be initialized, which leads the user through a specific refactoring. This includes also initializing the appropriate subtype implementation of the {\it RefactoringProcessor} class, which is defined as part of the Eclipse ltk library. 
This implementation will finally execute the real work, which is the actual surplus of the refactoring.

\chapter{Abstract refactorings}
\label{abstractRefactorings}
\section{What we mean by abstract refactoring}
Refactorings have the pecularity, that they can be grouped into classes, which appear to the user to be similar. In our case the only such group we really have defined is the renaming of program identifiers. All but the {\it extract function} refactoring are actually implemented as subtypes of the elements in the {\it abstractrefactoring.rename} package.
But we could also imagine other groups, i.e. in java there exist the group of generators, which generate some code for you or there are refactorings which allows you to push up code in a supertype or pull it down in a subtype.\\
The similiarities of the elements of such a group have a direct impact on the needed infrastructure, which is needed to execute such a refactoring. I.e. the user has the same input to do, and the same steps to follow.\\
The subpackages of the package {\it abstractrefactorings} right in the root package of the plugin, are intended to hold classes, which define the infrastructure for a specific group . This classes gather the code, which is reused for every element of a specific group. The direct consequence is writting less code, and especially introducing less errors, when creating new refactorings. Also in the sense of extensibility this package structure makes for sure sense.\\
Because nearly all of our refactorings are about renaming, we take a closer look on the associated classes in the {\it abstractrefactoring.rename} package.

\section{The {\it abstractrefactoring.rename} classes}
\subsection{The {\it RenameAvailabilityTester} abstract class}
Before a user is allowed to execute a rename refactoring, eclipse has to force him, to select a program identifier. Namely the identifier which has to be renamed.
The {\it RenameAvailabilityTester} implements the {\it IRefactoringAvailabilityTester} interface, which we already talked about in the last chapter.
Therefore it overrides the interface' {\it test} function. In this function it tries to get an identifier out of the given user selection. If this is not possible, the function will just return false, which means that the associated refactoring is not available for the selection.
Otherwise it calls its own abstract function {\it isSelectionAppropriate} which will solve the question, if the refactoring is available, in a subtype. This function has an argument of type {\it Identifier}, which is actually an AST element, which will be the currently selected identifier, during a call. 
This takes the burden of the subclasses, to find the identifier by themselves.
Such an implementation then normally solves the question in about four lines of code, by means of an instance of type {\it SelectionIdentifier}. 

\subsection{The {\it SelectionIdentifier} class}
\label{SelectionIdentifier}
Identifiers of an entity, which is to be renamed, appear mostly in different places for different purposes. I.e. a function identifier can be in a function definition, function declaration or a function call. 
A subtype of {\it SelectionIdentifier} is intended to identify the purpose, which a given identifier has.
This enables a {\it SelectionIdentifier} to identify the entity of a selected identifier and therefore, if a refactoring is available for the given selection. The information about the kind of entity of an identifier can  be found in the AST. 
This is the reason why the {\it SelectionIdentifier} class facilitates the {\it AstAnalyzerFactory} and its associated classes. About these classes will we talk in a later chapter.

\subsection{The {\it RenameActionHandler} class}
The {\it RenameActionHandler} class plugs together the classes, which are needed to set up the refactoring wizard. These are the {\it RenameInfo}, {\it RenameInputPage} and the {\it RenameProcessor} classes.
It takes all the work from its subclasses, such that they just have to provide their specific {\it RenameProcessor} instance.

\subsection{The {\it RenameInputPage} class}
This class builds the representation of the window, which the user will use to enter a new name for a given entity.
It is especially interesting, since it uses the {\it InputValidation} class to avoid renaming of identifiers to non C names. If the user enters an unappropriate name, proceed buttons will be disabled, until he corrects his input.

\subsection{The {\it RenameProcessor} class}
\label{RenameProcessor}
The {\it RenameProcessor} class extends the class with the same name from the Eclipse ltk library. It provides a lot of functions, which are reused in many subtypes. Besides this it enforces it subtypes to follow a little framework, by means of abstract functions.
Each subtype has to implement at least four functions:
   \begin{enumerate}
     \item {\it getProcessorName} with return type {\it String}
     \item {\it initializeRefactoring} with return type {\it RefactoringStatus}
     \item {\it checkConditionsAfterNameSetting}  with return type {\it RefactoringStatus}
     \item {\it createChange}  with return type {\it Change}
   \end{enumerate}
The {\it getProcessorName} function is expected to return the name of the entity, which is renamed by this refactoring. This string is used only for user output.\\
The {\it initializeRefactoring} function is the first function of a sublcass which will be called.
Here a subclass can gather all its information, to be sure, the refacoring is even possible or even has an effect.
Experience shows, that this is actually the function which gathers all {\it Identifier} AST nodes, which are affected by the renaming.
Errors in this function normally lead to adding an {\it FatalError} message to the returned {\it RefactoringStatus}, since the refactoring
will not be able to do any reasonable thing. A {\it FatalError} message is shown to the user and leads to an abort of the refactoring.\\
The {\it checkConditionsAfterNameSetting} function is the second function of a sublclass which will be called.
It is called after the user entered a new name for the entity to be renamed.
In this function a sub class can check if the new name is a reasonable choice.
Which means that this is the place were you should check, if renaming would lead to name collisions in the program.
Errors in this place are often not reported back as {\it FatalError} but just as {\it Error} messge instead.
If we report just an {\it Error} message, then the user still has the choice to  proceed. An {\it Error} message informs the user, that proceeding
will change the semantics of the source, or will even lead to compile errors. But since the user possibly wants such a change in semantics by intention, it was false to not allow proceeding.\\
The {\it createChange} function is the last function, which will be called by the {\it RenameProcessor} framework. It is the place where a subtype finally can create a subtype of {\it Change} class, from the Eclipse ltk library.
This object then should include all changes, which are necessary for the refactoring, to fullfil its task.

\chapter{Harnessing the AST}
\label{harnessingTheAST}
The Yeti NesC parser generates an AST. This AST includes all information about the NesC source code on a per file base. Big parts of our program build upon analyzing these ASTs, in order to find information about the program, which is to be refactored.
In early phases of the development, we used a lot of static code, to gather information out of the AST. This lead to a more imperative then object oriented design, with high coupling. Since this is an unpopular attribute for good software, we decided to refactor our refactoring plugin. 
The result was the birth of the so called {\it AstAnalyzer} classes.

\section{The {\it AstAnalyzer} classes}
\label{AstAnalyzerClasses}
This classes are intended to wrap AST's of a whole file, or at least parts of an AST. The interaction with an {\it AstAnalyzer} is more of the kind:"Give me all objects which have the property...'. I.e. you can ask a {\it CAstAnalyzer} to give you all global C functions, which appear in its AST.\\
Without the analyzers the interaction is more like:"I have an AST node, is this AST node of type A, and if so, is it a child of type B...''. This means that in the whole program appeared code fragments, which included actually knowledge dedicated to the AST. This is pretty much the opposite of coherence and encapsulation.

\subsection{The {\it AstAnalyzerFactory} class}
Basically we can distinguish the types of AST's included in a source file. I.e. has a AST of a NesC interface a different structure, then the one of a NesC module.
The {\it AstAnalyzerFactory} class takes an {\it ASTNode} or a source file and generates the appropriate {\it AstAnalyzer} type.\\
We than can ask the {\it AstAnalyzerFactory} which type it has created and can then read the associated type out of the factory.

\subsection{{\it AstAnalyzer} types}
For the {\it AstAnalyzers}, which represent a AST of a whole file, we have defined an hierarchy of types. It is shown in the graphic
\ref{AstAnalyzersTypeHierarchy} on page \pageref{AstAnalyzersTypeHierarchy}. Depending on the analyzer type we can get specific information. 
I.e. a {\it ModuleAstAnalyzer} will provide information about the Nesc code, which its module implementaion contains, while a {\it ConfigurationAstAnalyzer} holds data about the NesC wirings, which its configuration implementation includes.

\begin{figure}[h]
\centering
\includegraphics[height=.35\textheight]{AstAnalyzerTypesHierarchy.png}
\caption{ASTs, which represent a whole NesC source file, are abstracted by the {\it AstAnalyzer} type hierarchy.}
\label{AstAnalyzersTypeHierarchy}
\end{figure}

\section{Utility classes}

\subsection{Auxiliary AST classes}
As we already mentioned, our first approach was more kind of an imperative one. Because of time issues we were not able to totally get rid of the old design. Thats the reason why there exist still two classes, which are in the oldschool style.
   \begin{enumerate}
     \item {\it ASTUtil4Functions} class includes a lot of functions related to the AST structure of functions.
     \item {\it ASTUtil4Variables} class includes a lot of functions related to the AST structure of variables.
   \end{enumerate}
If we had have some more time, we probably had designed something like a {\it FunctionAstAnalyzer} class. This class than had replaced the other two, which had been more likely a good object oriented design.\\
A very useful class dedicated to the AST, is the {\it ASTUtil} class. It includes a lot of convenience functions, which are useful everywhere, where we interact with the AST.\\
Last but everything else then least we have to mention the {\it AstPositioning} class. This class's main task is to find the appropriate AST element for a given character position in a source file.
This task is complicated by the fact, that the position may come from a preprocessed file. The correct functioning of the class is especially mission critical for deciding the user selection.

\subsection{Project wide classes}
There is a number of further utility classes int the {\it utility} package.\\
The most important one is the {\it ProjectUtil} class. Refactorings which not only affect the file from which they were triggered, have to get access to other affected files.
Therefore the {\it ProjectUtil} class provides exactly the right functions. I.e. you can find a NesC Module by giving its name, or you can search for references to a specific {IASTModelPath} in a certain file.
A file is always the first step to get to its AST.\\
The {ProjectUtil} also includes functions for logging messages to the project log and some other stuff, which is related to the whole project.\\
Another interesting class is the {\it ParserCache} class. As its name says, it tries to cache Parsers, so that not every file has to be parsed again and again, even if it was not modified, since it was parsed the last time. In our implementation the parser cache is only in use, if you obtain your parser from the {\it ProjectUtil} class. 

\chapter{Concrete refactorings}
\section{Implemented refactorings}
One of the main parts of our work was of course the implementation of concrete refactorings. We have implemented the ones, which we thought were the most useful:
   \begin{enumerate}
     \item Renaming of local variables
     \item Renaming of function parameters
     \item Renaming of variables in the implementation scope of a NesC Module
     \item Renaming of global variables
     \item Renaming of C functions in the implementation scope of a NesC Module 
     \item Renaming of global C functions
     \item Renaming of NesC functions, like events and commands
     \item Renaming of NesC interfaces
     \item Renaming of NesC Components, like modules and configurations
     \item Renaming of NesC component aliases
     \item Renaming of NesC interface aliases
     \item Introducing of NesC component aliases
     \item Introducing of NesC interface aliases
     \item Extracting of code parts to new C functions
   \end{enumerate}
As we can see, most of the refactorings are related to renaming something. In fact even the introducing of aliases is realised as a rename refactoring. This is the reason why we took a closer look at the classes in the {\it abstractrefactoring.rename} package. 
The refactorings, which use the infrastructure, given in this package, the implementation reduces to implementing not more then four classes:
   \begin{enumerate}
     \item A {\it ActionHandler} class as subtype of {\it RenameActionHanlder}
     \item A {\it AvailabilityTester} class as subtype of {\it RenameAvailabilityTester}
     \item A {\it SelectionIdentifier} class as subtype of {\it SelectionIdentifier}
     \item A {\it Processor} class as subtype of {\it RenameProcessor}
   \end{enumerate}
It is even simpler, since the {\it AvailabilityTester} and the {\it ActionHandler} classes are kind of connector classes to the {\it SelectionIdentifier} and {\it RenameProcessor}, respectively. This means that they have about three lines of code and do not much more than instantiating the other class.\\
The only refactoring, which we have implemented, which does not rely on the rename infrastructure, is the refactoring for extracting code parts to new C functions. This is besides the complexity of it a second reason, why it has much more code.

\section{What else could be done}
If we had more time, there were of course a lot, which we could have done too. Everybody who can write code knows, that there is always something, which could be done nicer or more efficient. In short, there is always something, which you can refactor.
I.e. as we already mentioned, it was nice to get rid of the {\it AstUtil4Functions} and {\it AstUtil4Variables} classes and instead implement something like a {\it FunctionAstAnalyzer} class, to reach a nicer, more object oriented design style.\\
With more time we also could have implemented some more refactorings, i.e.:
    \begin{enumerate}
     \item Renaming of global C typedefs
     \item Renaming of C typedefs in the implementation scope of a NesC Module
     \item Renaming of C enums, as well in the global as in the implementation scope
     \item Renaming of C enum constants
     \item Renaming of C structs, as well in global as in the implementation scope
     \item Renaming of NesC tasks
     \item Renaming of C preprocessor macros
     \item More sophisticated extract function refactoring, which allows user to select in and out parameters
     \item Magic number refactoring, which converts magic numbers to constants
   \end{enumerate}
And we are sure, there are a lot more of possibilities.

\section{How to implement a new refactoring}
If you intend to implement a new refactoring, this section should give you an overview, which steps you have to follow, and where in this document you can find more information to a specific topic.

\subsection{Enable your refactoring}
First you have to add new, appropriate elements in the {\it plugin.xml} for your refactoring. The fastest way to do this is to copy and paste existing elements, and adapt their content. You have to add the following elements:
   \begin{enumerate}
    \item A {\it command} element in the {\it commands extension} element, important is the {\it id} attribute, since it is referenced in all other elements
    \item A {\it handler} element in the {\it handlers extension} element, important is the {\it class} attribute, which references the handler implementation
    \item A {\it command} element in the {\it menu menuContribution} element under the menus {\it extension} element, important is the {\it label} attribute, which is the name shown to the user and the {\it property} attribute, since it identifies the refactoring in the property tester
    \item A {\it command} element in the {\it popup menuContribution} element under the menus {\it extension} element, important is the {\it label} attribute, which is the name shown to the user and the {\it property} attribute, since it identifies the refactoring in the property tester
   \end{enumerate}
Finally you have to add the {\it property} string, which you have specified in the {\it command} elements, which you added to the {\it menuContribution} elements, to the {\it properties} attribute in the {\it propertyTester extensinon} element.\\
This is all you have to do with the {\it plugin.xml}, in order to introduce your new refactoring.
If this information is not enough for you, maybe you find some answers in chapter \ref{menuWithConditionalVisibility} on page \pageref{menuWithConditionalVisibility}.

Now you have to create a subtype of {\it IRefactoringAvailabilityTester}. It has to test, if the user selection is appropriate for your refactoring.
The last step in order to enable your new refactoring, is to define a new enum constant in the {\it Refactoring} enum.
Make sure that its {\it propertyName} field matches the {\it property} name you chose in the {\it plugin.xml} and set your new {\it IRefactoringAvailabilityTester} as its {\it tester} field.\\
If you have done all these steps, you should now see your refactoring in the Eclipse user interface, if the user selection matches your definitions.
If you need more information about these two steps, consult chapter \ref{fromPluginXMLToJavaCode} on page \pageref{fromPluginXMLToJavaCode}.

\subsection{Make your refactoring do its work}
You should now be able to select your refactoring in the Eclipse user interface. To make the selection do your refactoring, you have to do the following steps.
First you have to implement a subtype of the Eclipse {\it AbstractHandler} class.
Make sure that the class name matches the one given in the {\it plugin.xml} in the {\it handler} element.
This class is responsible for initiating your refactoring. You should do this by facilitating the language toolkit for processor based refactoring.
This means that you have to create subtypes of the following classes: refactoring wizard, give it an input page for user input, and a refactoring processor.
   \begin{enumerate}
    \item {\it DefaultRefactoringWizard} class of us, responsible for consolidating the following classes
    \item {\it RefactoringInfo} class of us, carries information needed by the refactoring and the wizard itself
    \item {\it UserInputWizardPage} of Eclipse, the window, where the user can do its input
    \item {\it RefactoringPorcessor} of Eclipse, the place where the changes actually are generated
   \end{enumerate}
To find out more about this classes, read chapter \ref{languageToolkitForProcessorBasedRefactoring} on page \pageref{languageToolkitForProcessorBasedRefactoring}.
If you implemented and wired them correctly, your refactoring should now be able to do its work.\\
If you intend to write a rename refactoring, you can extend the classes from the {\it abstractrefactoring.rename} package.
If you do so, your only real concern is to write a subtype of the {\it RenameProcessor} class.
In this case you should take a look at chapter \ref{abstractRefactorings} on page \pageref{abstractRefactorings}.\\
For writing a processor you should consider to reuse the classes explained in chapter \ref{harnessingTheAST} on page \pageref{harnessingTheAST}.\\
If all this information is not enough, you can read the source code, which is still the most accurate Documentation.

\chapter{An example Implementation: The rename interface refactoring}
In this section we talk about the implementation of the {\it rename interface} refactoring. As its name suggest, the target of the refactoring is to rename a NesC interface.
Since the refactoring is about renaming, it makes heavy usage of the infrastructure in the {\it abstractrefactoring.rename} package.
This package is described in chapter \ref{abstractRefactorings} on page \pageref{abstractRefactorings}.

\section{Until the processor starts its work}
We assume that the developer is working in a NesC Project and has saved all his Editors. He wants to rename one of his Interfaces. To do that he double-clicks on the old
name of the interface. 

Eclipse marks it and fires a {\it Selection Changed} event. 
This triggers, among other things, the checks which entries are to be displayed in the refactoring menu.\footnote{Defined as described in \ref{conditionalVisibility} on page \pageref{conditionalVisibility}.}
This means that  Eclipse has to call the {\it AvailabilityTester} property tester for each possible menu entry with the according property. When Eclipse comes to the 
{\it  renameInterface} property, the global AvailabilityTester will call the {\it test()} method of the rename interface {\it AvailabilityTester}. This method will find the 
identifier the user marked and pass it to the {\it InterfaceSelectionIdentifier} class. This class checks if the identifier represents an interface. And yes, it does. 
The {\it AvailabilityTester} returns {\it true} and Eclipse knows that the rename interface refactoring has to be part of the refactoring menu if the user opens it.

All this checks were done so fast that the user did not notice anything. He just selected an interface name. He opens the refactoring menu and Eclipse already knows what entries
it has to show. The user clicks on {\it Rename Interface}.

Eclipse now create an Object of the {\it ActionHandler} defined in the {\it plugin.xml} {\it handler} tag\footnote{As described in \ref{commandHandler} on page \pageref{commandHandler}.} and calls the {\it execute()} method. 
The {\it execute} method initializes all the necessary LTK classes\footnote{Described in \ref{languageToolkitClasses} on page \pageref{languageToolkitClasses}.} 
or there rename interface subclasses. Among them the {\it Processor} and the {\it Wizard}. Then it starts LTK's {\it RefactoringWizardOpenOperation}.
\footnote{Well illustrated by the interaction diagram\ref{refactoringOperationSequence} on page \pageref{refactoringOperationSequence}.}
It checks the initial conditions and shows the {\it RenameInputPage} to the user.

The user who just clicked on {\it Rename Interface} can now enter the new name he wants the Interface to have. While he does that, Eclipse check whether he enters
a valid C identifier and allows him to click preview or OK, only if a possible string was written. Cause the user entered a name which generates no problems, he is allowed to click on
preview. Eclipse checks the final conditions and calls the {\it createChange} method of the processor. The user can preview the changes and accepts them by clicking on OK.
\section{The processor}
Now we come to the point, where the real work happens. The class {\it tinyos.yeti.refactoring.entities.interfaces.rename.Processor} has to do three steps, to successfull rename an interface:
   \begin{enumerate}
    \item Find all identifiers affected by the renaming, most probably in several files.
    \item Check that the new name does not collide with an existing one.
    \item If there are no collisions, create the changes.
   \end{enumerate}
The processor extends the {\it tinyos.yeti.refactoring.abstractrefactorings.rename.RenameProcessor} class. It is explained in detail in chapter \ref{RenameProcessor} on page \pageref{RenameProcessor}.
Therefore the processor implements the mini framework we mentioned in this chapter. The three framework functions perfectly match on our three steps:
   \begin{enumerate}
     \item Find all identifiers realised in function {\it initializeRefactoring}
     \item Collision detection realised in function {\it checkConditionsAfterNameSetting}
     \item Change creation realised in function {\it createChange}
   \end{enumerate}
We will now go on with explaining the actions taken in the different functions.

\subsection{Find all identifiers affected by the renaming}
The functionality described here is implemented in the {\it initializeRefactoring} function of our mini framework.
In order to find all identifiers affected by the renaming, we do the following:
   \begin{enumerate}
     \item Find the source file, which defines the interface.
     \item Check all project files for references to the interface definition.
     \item Convert the found references to identifiers.
     \item Check if the identifiers need to be renamed.
     \item pack all identifiers in a map, mapped by the file in which they appear.
   \end{enumerate}
To find the source file, we are in the lucky position, that the selected identifier has to have the name of the Interface, which is to be renamed. 
A special case is it, when the selection is actually an interface alias, but for our example implementation, this case is not relevant. 
With the name of the interface to be renamed in our hands, we can use the class {\it ProjectUtil}. This class makes use of the facilities provided by the Yeti plugin.
It is able to get a {\it IDeclaration} class for the interface name out of the {\it ProjectModel} class. The declaration is actually an abstraction of the interface source file. 
At this point we have fulfilled our first step for the renaming.\\
In order to find all references to the interface, we proceed as follows. The declaration we found in the first step has a {\it IASTModelPath}. 
We can use this path to gather all references of a specific file to the path. This is done via the Yeti {\it ProjectModel} again.\\
Now we come to the third step. We have now the references to the interface, but we are not able to rename based on the references.
The reason is, that we have to do checks, if the identifiers behind the references are actually identifiers of interest, see the next step therefore.
The references can be converted to {\it Identifer} AST nodes, which are also defined by Yeti. This conversion is done by means of our {\it AstPositioning} class.
It takes an offset in a source file and gives you in turn the AST node at this position. 
You then can check if it is actually of the expected type, and your done with this step.\\
You have now the identifiers and the containing files. Unfortunately not all of this identifiers need to be renamed. First there is the possibility, that a reference 
spans more than one Identifier. Normally not both of them reference an interface and most probably not both the one we are looking for. 
Second, also interface aliases reference the defining interface, but we are not interested in renaming aliases. This means that we have to filter our bunch of identifiers.
To fulfill this task, we use our {\it InterfaceSelectionIdentifier} class (chap. \ref{SelectionIdentifier}, page \pageref{SelectionIdentifier}), which makes heavy use of the {\it AstAnalyzerClasses}(chap. \ref{AstAnalyzerClasses}, page \pageref{AstAnalyzerClasses}).\\
Now we have all identifiers we are interested in according with the files, in which they appear. 
We then put this identifiers in a map, mapped by the file, to have access to it in the remaining two steps of our mini framework.

\subsection{Check for collisions}


\subsection{Create the changes}

\nomenclature{AST}{AST stands for abstract syntax tree. The yeti NesC parser generates for each source file such an AST. It is a first abstraction of the source code, based on the NesC syntax.}
\nomenclature{OSGi}{The OSGi framework is a module system and service platform for the Java programming language that implements a complete and dynamic component model, something that does not exist in standalone Java/VM environments. Applications or components (coming in the form of bundles for deployment) can be remotely installed, started, stopped, updated and uninstalled without requiring a reboot; management of Java packages/classes is specified in great detail. Life cycle management is done via APIs which allow for remote downloading  of management policies. The service registry allows bundles to detect the addition of new services, or the removal of services, and adapt accordingly. (from Wikipdedia)}
\renewcommand{\nomname}{Glossary}
\printnomenclature

\end{document}          
